# chat

## 1. 引言

**背景**
现代网络浏览器是攻击者的主要目标，因为它们连接用户与网络世界。特别是自COVID-19疫情以来，工作和教育转移到家用电脑上，使得浏览器变得更加关键。如果攻击者能诱使用户访问恶意网站，就能利用浏览器漏洞窃取敏感数据（如网上银行或社交网络的凭证）。

**浏览器的安全措施**
为了应对这些安全威胁，浏览器厂商已经做出了巨大努力来保护用户安全。尤其是，浏览器架构已经发展到严格执行最小权限原则（PoLP）。现代浏览器通过以下两种技术实现这一点：

1. **多进程架构**：将浏览器分为渲染进程和浏览器进程。渲染进程处理远程内容，权限受限。浏览器进程负责管理渲染进程和与用户交互，权限较高。
2. **站点隔离**：最近在Chrome和Firefox中采用，将每个渲染进程分配给单一网站，从而在进程级别执行同源策略（SOP）。

这些技术使得攻击者很难成功攻破浏览器，仅控制渲染进程无法获得高权限，因为渲染进程被沙盒化，限制了对系统资源的访问。此外，站点隔离使得攻击者无法从其他网站窃取用户数据。因此，攻击者需要找到其他漏洞绕过这些防护措施。

**扩展程序的安全性**
本文分析了浏览器扩展程序的安全性。扩展程序是第三方程序，旨在丰富浏览体验。它们有两大特性：

1. **访问特权API**：扩展程序可以访问普通网页无法访问的浏览器API，如Cookie、书签、浏览历史等。
2. **处理安全关键数据**：扩展程序处理的安全数据不仅限于当前浏览的网站，还包括其他网站和用户的数据，如密码管理器和加密货币钱包。

为了增强安全性，扩展程序架构也遵循PoLP，分为内容脚本和扩展页面。内容脚本与可能的恶意网页交互，权限较低；扩展页面权限较高，可以访问特权API，并在独立的进程中运行。

**存在的安全问题**
然而，当前的浏览器（包括Chrome、Firefox和Safari）在执行PoLP时存在关键安全缺陷。扩展程序的安全依赖于第三方开发者的严格安全要求，但开发者通常不是安全专家，难以满足这些要求。我们发现了40个扩展程序中的59个漏洞，攻击者可以利用这些漏洞绕过PoLP进行权限提升攻击。

**解决方案：FISTBUMP**
为了应对这些安全缺陷，我们提出了FISTBUMP，一个新的扩展程序架构，通过强隔离机制设计，满足所有安全要求并消除所有漏洞。FISTBUMP设计保持了扩展程序的向后兼容性，不需要对现有扩展程序进行修改。此外，FISTBUMP集成了批量请求模型来优化运行时性能。

**总结**
本文的主要贡献包括：

1. 分析现有扩展架构的安全限制，特别是在渲染进程被攻破的情况下。
2. 发现了现代浏览器扩展程序中的59个权限提升漏洞。
3. 设计并实现了FISTBUMP，一个新的安全扩展架构，通过强隔离机制消除所有漏洞。

## 2. 背景

本节介绍了有关网络浏览器安全性和扩展架构的背景信息。

### 2.1 网络浏览器安全性

**现代浏览器的安全设计**

现代网络浏览器遵循最小权限原则（PoLP），将功能分成多个进程，每个进程通过操作系统提供的强隔离边界进行保护。

**多进程架构**

浏览器分为浏览器进程和渲染进程。

渲染进程处理不可信的网络内容，因此权限受限，不能直接进行系统调用或访问其他进程的内存。

而浏览器进程是特权进程，通过它渲染进程访问资源，并负责进程间通信（IPC）。这样，即使渲染进程被攻破，也能限制对用户机器的损害，其他进程仍然安全。

**渲染进程的威胁**

尽管渲染进程被多进程架构沙盒化，但在某些情况下，不同网站可能在同一个渲染进程中渲染。攻击者如果能读取或写入渲染进程的地址空间，就能访问该进程中所有网站的数据，违反同源策略（SOP）。

1. **AttackerRW**：拥有读取和写入渲染进程内存能力的攻击者，通常通过利用渲染引擎中的内存损坏漏洞实现。
2. **AttackerR**：只拥有读取渲染进程内存能力的攻击者，通常通过利用CPU微架构漏洞（如Meltdown和Spectre）实现。

**站点隔离**

为应对这些攻击，Chrome和Firefox采用了强站点隔离措施，确保每个独特站点在不同的渲染进程中加载，限制了被攻破的渲染进程的影响范围，防止AttackerRW和AttackerR违反SOP。

这些措施有效减少了攻击事件，例如在2022年，Chrome中没有报告任何UXSS漏洞，只有八个沙盒逃逸漏洞。

### 2.2 浏览器扩展架构

**扩展程序的设计**

浏览器扩展是用户安装的第三方程序，用于扩展浏览器功能。现代浏览器（如Chrome、Firefox、Safari）支持基于Web技术（如HTML、JavaScript和CSS）的Chrome扩展或WebExtensions API。

**权限控制**

扩展程序采用基于权限的访问控制。每个扩展程序必须在安装时声明所需的权限，用户需在安装时确认。这些权限包括扩展程序可以访问的浏览器API和可以激活的网页列表。由于权限在安装时确定，运行时无法扩展，因此限制了被攻破扩展程序的影响。

**架构分离**

扩展程序分为高权限的扩展页面和低权限的内容脚本。扩展页面运行在专用进程中，能够访问浏览器API，并通过SOP和站点隔离进行保护。内容脚本直接与网页交互，注入到渲染进程中，因此权限较低，风险较高。

**扩展消息传递**

由于扩展页面和内容脚本运行在不同进程中，二者通过消息传递进行通信。内容脚本可以请求扩展页面执行特权操作。

**扩展存储**

浏览器支持持久数据存储，扩展程序能够保存用户数据。存储在浏览器进程中，每个扩展程序有独立的存储空间。

**示例：密码管理器扩展**

例如，一个保存网站登录凭证的扩展程序，用户在登录页面输入凭证后，这些凭证存储在扩展存储中。之后，当用户访问登录页面时，扩展程序会自动填写相应的凭证。此外，该扩展程序还提供一个管理页面，显示所有保存的凭证，通过内容脚本和扩展消息传递获取和显示这些信息。

## 3. 安全要求以防范渲染进程攻击者

本节分析了扩展设计的安全要求，以应对渲染进程攻击者的最新威胁。随着渲染引擎复杂度的增加，漏洞数量也在上升。尽管已经部署了多种防御和缓解机制（如站点隔离），以防止渲染攻击者获得更多权限，但扩展安全性已成为主要的防线。

具体来说，内容脚本运行在渲染进程中，因此AttackerR和AttackerRW可以分别读取或写入内容脚本。根据最小权限原则（PoLP），获得这些能力不应赋予攻击者额外的权限，因为内容脚本是扩展的非特权组件，运行在非特权渲染进程中。因此，攻击者仍然无法访问提供给特权扩展页面的浏览器API，也不能访问浏览器进程提供的系统资源。

然而，我们发现，如果扩展开发者不严格遵循某些安全要求，当前的PoLP实施将变得无效，导致权限升级。不幸的是，并非所有扩展开发者都是安全专家，他们也缺乏编写安全扩展的动力。在本节中，我们介绍了扩展开发者需要遵循的三项安全要求，以及这些要求是如何被违反的，导致严重的安全漏洞。

### 3.1 扩展消息认证

内容脚本可以发送扩展消息请求特权操作，因此扩展页面需要验证发送消息的内容脚本是否合法。特别是，AttackerRW可以伪造IPC（进程通信）消息。

**安全要求1：扩展页面应验证扩展消息的发送者是否合法。**

许多扩展页面未能满足这一要求，可以分为两类：1）不验证发送者；2）错误地验证发送者。例如，使用URL进行验证可能不可靠，因为某些URL需要特殊处理。

举例来说，密码管理器扩展应仅接受来自管理页面的内容脚本的凭证请求。如果扩展页面不检查发送者，攻击者也能请求凭证。

```jsx
javascript复制代码
// 脆弱的扩展背景页面
chrome.runtime.onMessage.addListener((message, sender, send) => {
  // 错误地验证URL
  if (sender.url.startsWith("https://admin.com") && message == "getCredentials")
    sendResponse(credentials);
});

// AttackerRW在https://admin.com.attacker.com上
chrome.runtime.sendMessage("getCredentials")

```

### 3.2 扩展存储中的非敏感数据

扩展存储用于存储扩展的持久数据，可被扩展页面和内容脚本访问。因此，一旦渲染进程被攻破，AttackerRW可以读取和修改扩展存储的数据。

**安全要求2：扩展不应在扩展存储中存储安全关键、隐私敏感或跨站点的数据。**

许多开发者误认为扩展存储只能被他们编写的扩展页面和内容脚本访问，因此存储了敏感数据。例如，密码管理器扩展将凭证存储在扩展存储中，允许攻击者非法访问这些凭证。

```jsx
javascript复制代码
// 脆弱的扩展背景页面
// 在扩展存储中存储凭证
chrome.storage.set("credentials", credentials);

// AttackerRW在任何页面上
chrome.storage.get("credentials")

```

### 3.3 内容脚本中的非敏感数据

内容脚本在渲染进程中运行，因此AttackerR和AttackerRW可以读取内容脚本的数据。这特别危险，因为AttackerR不依赖于浏览器中的漏洞，难以缓解。

**安全要求3：扩展不应在内容脚本中加载安全关键或隐私敏感的数据。**

许多扩展未能遵循这一要求，开发者认为内容脚本中的数据只能被内容脚本访问。例如，背景页面向内容脚本发送敏感数据，而AttackerR可以读取这些数据。

```jsx
javascript复制代码
// 脆弱的扩展背景页面
// 向内容脚本发送敏感数据
chrome.tabs.sendMessage(tabId, sensitiveData);

// 消息被放入渲染进程的消息队列，AttackerR可以读取消息
readMemory();

```

# 摘要

UXSS(通用跨站点脚本)

最小权限原则(PoLP)，一个浏览器实例被划分为多个功能组件，每个组件只被授予执行给定任务所需的特权。

多进程架构

站点隔离

### FISTBUMP，一种新的扩展架构

FISTBUMP通过强隔离机制（如将内容脚本与渲染进程隔离）来增强最小权限原则（PoLP）的执行，从而消除了所有已发现的漏洞。此外，FISTBUMP的设计保持了扩展程序的向后兼容性，现有扩展程序无需修改即可运行。

# 1 简介

### 多进程架构

渲染进程： 处理远程内容

浏览器进程：协调渲染进程并与用户交互

### 站点隔离

在进程级别强制执行浏览器的基本安全原则——SOP同源策略\

# 7 评估

### 安全性

FISTBUMP框架通过以下几个方面增强了安全性：

1. **进程隔离**：
    - FISTBUMP采用进程隔离技术，将内容脚本和扩展页面分离到不同的进程中。
    - 这种隔离确保即使内容脚本或渲染进程被攻击者控制，也无法直接影响高权限的扩展页面，从而减少了权限提升的风险。
2. **DOMProxy机制**：
    - DOMProxy用于监控和过滤内容脚本对DOM的访问请求。
    - 它能够拦截潜在的恶意访问，确保内容脚本无法访问或修改敏感信息。
3. **强化的权限控制**：
    - FISTBUMP严格遵循最小权限原则（PoLP），确保内容脚本只能访问必需的资源和数据。
    - 通过权限检查和认证机制，防止未经授权的操作。

### 向后兼容性

FISTBUMP在设计时考虑到了与现有浏览器扩展的兼容性：

1. **API兼容性**：
    - FISTBUMP尽量使用现有的浏览器扩展API，确保现有的扩展可以在不做大幅修改的情况下运行。
    - 通过适配层和兼容模式，现有扩展可以平滑过渡到FISTBUMP框架。
2. **开发者友好性**：
    - 保持扩展开发的简单性，不要求开发者学习新的编程范式。
    - 提供详细的文档和示例，帮助开发者快速上手和迁移现有扩展。

### 性能

FISTBUMP框架在性能方面进行了优化，确保其增强安全性的同时不显著影响浏览器的运行速度：

1. **轻量级隔离**：
    - 进程隔离虽然引入了额外的开销，但通过优化进程间通信（IPC）和资源管理，减少了性能影响。
    - 采用高效的资源调度机制，确保进程间的数据交换快速且低延迟。
2. **DOMProxy优化**：
    - DOMProxy在拦截和过滤DOM访问时，采用了高效的算法，保证对网页交互的延迟最小化。
    - 通过智能缓存和批处理技术，减少了多次重复访问带来的性能损耗。

---

### 🌰例子

```jsx
// 创建一个 DOMProxy 代理对象
function createDOMProxy(element) {
    if (element.property === 'innerHTML' || property === 'innerText') {
        // 检查访问的属性是否是敏感信息
        if (element.target.id === 'user-name' || target.id === 'user-email') {
            return 'Access Denied';
        }
    }
    return target[property];
}
// 获取用户信息区域的 DOM 元素
const userNameElement = document.getElementById('user-name');

// 创建代理对象
const userNameProxy = createDOMProxy(userNameElement);

// 示例访问和修改
console.log(userNameProxy.innerText);  // 输出 "Access Denied"
```
---
# 译文
---
# 2 背景

本节描述了网络浏览器安全性（§2.1）和扩展架构（§2.2）的背景信息。

## 2.1 网络浏览器安全性

现代网络浏览器遵循最小特权原则 (PoLP)，并将其功能分成多个进程，其中每个进程由操作系统（OS）提供的强隔离边界保护。

### 多进程架构

浏览器被分为两类进程：浏览器进程和渲染进程。渲染进程负责渲染不受信任、可能存在恶意内容的网页。因此，渲染进程是不受信任的，不能直接进行系统调用或访问其他进程的内存。

另一方面，浏览器进程是特权进程，渲染进程通过它访问资源。浏览器进程还充当渲染进程之间的中介，负责进程间通信（IPC）。这限制了渲染进程被攻破后对用户机器造成的损害，即使渲染引擎中的漏洞被利用，一个渲染进程被攻破，特权浏览器进程和其他渲染进程仍然是安全的。

### 对渲染进程的威胁

尽管渲染本身受到多进程架构的沙箱保护，但在某些情况下，不同站点可能在同一个沙箱（渲染进程）中渲染。每个源在软件级别上是逻辑隔离的，但这种边界对抗最近网络攻击者的威胁并不够强。

具体来说，考虑那些能够读写渲染进程地址空间的攻击者。由于不同站点在同一个渲染进程中渲染，这些攻击者可以访问该进程中所有网站的数据，违反了网络安全的基本原则——同源策略 (SOP)。在本文中，我们将这些攻击者称为AttackerRW和AttackerR。

<aside>
<img src="/icons/circle-alternate_brown.svg" alt="/icons/circle-alternate_brown.svg" width="40px" /> 首先，AttackerRW 是获得渲染进程内存读写能力的攻击者。这种能力可以通过利用渲染引擎中的内存损坏漏洞来实现，使AttackerRW能够执行任意代码并进行通用跨站脚本（UXSS）攻击。由于渲染引擎的复杂性，这类漏洞非常常见。实际上，Chromium 开发者曾表示“[我们]假设决心强烈的攻击者能够找到攻破渲染进程的方法”。

</aside>

<aside>
<img src="/icons/circle-alternate_brown.svg" alt="/icons/circle-alternate_brown.svg" width="40px" /> 其次，AttackerR 是获得渲染进程内存读取能力的攻击者。这可以通过利用CPU瞬态执行的微架构侧信道漏洞实现，如Meltdown和Spectre。这些攻击的独特之处在于它们依赖于微架构中的漏洞，而不是浏览器，因此难以缓解。

</aside>

### 站点隔离

这些攻击促使Chrome和Firefox采用了强站点隔离机制，分别称为Chrome的站点隔离和Firefox的Fission。站点隔离确保每个独特站点在不同的渲染进程中加载，并过滤网络请求中的跨站数据。例如，嵌入在example.com中的example.org将加载在与托管example.com的渲染进程不同的进程中，并且尝试请求example.org的数据将被浏览器进程阻止。站点隔离限制了受损渲染进程的影响，仅限于托管该站点的进程，防止AttackerRW和AttackerR违反SOP。

这些措施已被证明对这些威胁具有有效的缓解作用。2022年，Chrome中没有报告任何UXSS漏洞，仅有八个沙箱逃逸漏洞（其中四个需要受害者安装恶意扩展）。只有五个漏洞允许AttackerRW升级为沙箱逃逸，相比之下有196个漏洞可能授予读写能力。

## 2.2 浏览器扩展架构

浏览器扩展是用户安装的第三方程序，用于扩展浏览器功能。扩展通过扩展API与浏览器连接。大多数现代浏览器，包括Chrome、基于Chromium的浏览器（如Edge、Opera、Brave）、Firefox和Safari，都支持Chrome扩展或WebExtensions API，该API基于HTML、JavaScript和CSS等网络技术。其他插件接口，如ActiveX、NPAPI、PPAPI和XPCOM已被弃用和移除，剩下的只有Chrome/WebExtensions。值得注意的是，Safari应用扩展也可以被视为插件接口，但由于它是常规的macOS应用程序，本文不予考虑。

### 扩展架构的安全原则

遵循网络浏览器的一般安全原则（§2.1），网络扩展架构也设计为最小特权原则。首先，扩展通过基于权限的访问控制进行保护。每个扩展应在manifest.json文件中声明所需权限列表，用户在安装扩展时需要确认这些权限。权限包括扩展可以访问的浏览器API（如历史记录、Cookie、书签）列表。权限还包括扩展可以激活的网站列表。由于权限在安装时确定，并且在运行时不能扩展，因此受损扩展的影响仅限于预先声明的权限。

其次，扩展架构将扩展分为两部分：高特权的扩展页面，运行在专用的扩展进程中；和低特权的内容脚本，注入到渲染进程中以直接与网页交互，因此风险更高。

### 扩展页面

扩展页面可以访问上述浏览器API，并且可以对任何源进行HTTP请求，只要在manifest中声明了权限。为了与不受信任的网页内容隔离，扩展页面运行在专用进程中，这是一种特殊形式的渲染进程。此外，扩展有其自己的唯一ID，我们称之为IDEXT。IDEXT作为某些扩展页面的来源，通过SOP和站点隔离将扩展页面与网站和其他扩展隔离开来。扩展页面可以在后台运行，监视并响应事件，例如收到消息、打开标签页或请求网页时。

### 内容脚本

内容脚本是扩展的不受信任组件，使扩展能够直接与不受信任的网页交互。当特定网页加载时，内容脚本被注入到该页面，并通过文档对象模型 (DOM) 修改页面内容。由于内容脚本需要访问页面的DOM，因此内容脚本在与页面相同的渲染进程中运行。因此，内容脚本的风险更高，因而是不受信任的。为了访问浏览器API，内容脚本应通过消息传递依赖扩展页面。此外，内容脚本与页面具有相同的来源，不能请求跨源数据，强制执行站点隔离。

为了将内容脚本与在同一渲染进程中运行的不受信任的页面脚本隔离开来，内容脚本运行在一个隔离的环境中，这是一种基于软件的隔离机制，提供一个私有执行环境。隔离环境有自己的JavaScript堆和DOM包装器。因此，页面脚本无法访问内容脚本定义的变量，即使内置对象被页面脚本修改，内容脚本也会看到自己的版本，反之亦然。例如，即使内容脚本定义了document.foo，页面脚本也无法看到document.foo的定义，反之亦然。

### 扩展消息

由于扩展的两个组件，扩展页面和内容脚本，运行在不同的进程中，它们之间的通信通过消息传递进行。通过发送消息，不受信任的内容脚本可以请求扩展页面提供的特权操作。扩展消息由发送消息的组件构建，包含三个字段：发送者、接收者和负载。发送者表示发送消息的组件，包括IDEXT、URL和扩展页面或内容脚本的来源信息（即，在内容脚本的情况下，指定相应页面的信息）。接收者表示消息的目标组件，包括组件类型和IDEXT。负载是传递的数据，序列化为JavaScript对象表示法 (JSON)。然后，通过浏览器进程的IPC中继，消息被传递到指定的接收者。

### 扩展存储

浏览器支持扩展的持久数据存储，称为扩展存储。使用此存储，扩展能够存储各种用户数据，即使浏览器重新启动后也会保留。存储位于浏览器进程中，每个扩展有一个单独的专用存储，即存储与IDEXT相关联。因此，扩展组件无法访问其他扩展的存储。扩展页面和内容脚本都可以通过向浏览器进程请求来访问存储。

### 示例：密码管理器扩展

考虑一个ID为E的扩展，保存网站的凭据（包括ID和密码）。访问任何登录页面时，扩展提供一个界面供用户输入凭据。然后这些凭据存储在扩展存储中。当用户稍后访问登录页面时，扩展会自动填写相应的凭据。

该扩展还提供一个特殊的管理员页面，显示已保存凭据的完整列表。具体来说，当用户访问管理员页面时，内容脚本（记为C）被注入管理员页面，并请求已保存凭据的列表。该请求通过扩展消息完成，包含以下信息：i）消息由注入管理员页面的内容脚本C发送；ii）消息目标为E的扩展页面；iii）请求获取凭据。

一旦扩展页面E收到消息，它从浏览器进程中的扩展存储中检索凭据列表，并将其发送回内容脚本C。

# 3 防御渲染器攻击者的安全要求

本节分析了扩展设计的安全要求，以防范近期渲染器攻击者的威胁。随着渲染引擎复杂性的增加，漏洞数量也在上升。此外，各种防御和缓解机制（如站点隔离）已被部署，防止渲染器攻击者获得额外的能力。因此，扩展安全性已成为主要的防御线。

具体来说，内容脚本在渲染器进程中运行，因此攻击者R和攻击者RW分别获得了读取或写入内容脚本的能力。根据最小特权原则，获得对内容脚本的这种能力不应授予攻击者额外的能力。这是因为内容脚本是扩展的非特权组件，在非特权的渲染器进程中运行。因此，攻击者仍然无法访问提供给特权扩展页面的浏览器API，也无法访问浏览器进程提供的系统资源。

然而，我们发现当前的最小特权原则对扩展的执行是安全的，前提是扩展开发人员在开发扩展时严格遵守某些安全要求。如果违反了这些安全要求，则最小特权原则将变得无效，导致特权升级。不幸的是，并非所有扩展开发人员都是安全专家，他们在编写安全扩展方面的动机较低。在本节的其余部分中，我们将介绍扩展开发人员需要遵循的三个安全要求，以及每个要求如何被违反，从而导致严重的安全漏洞（如图3所示）。

## 3.1 扩展消息认证

内容脚本可以发送扩展消息请求扩展页面提供的特权操作。在这种情况下，扩展消息是由低特权组件（内容脚本）发送并传递给高特权组件（扩展页面）。因此，扩展页面必须彻底检查发送者内容脚本是否合法并能够请求此类操作。这在存在攻击者RW的情况下尤为重要，因为攻击者RW可以伪造用于交换扩展消息的IPC消息。

**安全要求1**：扩展页面应验证扩展消息发送者内容脚本是否合法。

然而，我们发现扩展开发人员经常无法满足这一安全要求。完整的易受攻击扩展列表见表1。这些失败可分为以下两种情况：1）扩展页面未验证发送者；2）扩展页面错误地验证了发送者。

1. 首先，许多扩展页面未验证发送者。我们怀疑这是因为许多扩展开发人员未考虑攻击者RW的威胁模型，即扩展消息可能被伪造。
2. 其次，许多扩展页面错误地验证了发送者，可能是因为正确地进行这种验证在技术上具有挑战性。一个典型的例子是使用作为发送者信息一部分的URL验证发送者。URL解析是棘手的，因为某些URL需要特殊处理；URL可以是about:blank, about:srcdoc, data:, blob:等特殊URL，并且来源可以是不透明的，即null。

🌰 另一个实例是检查时和使用时的竞态条件（TOCTOU）。例如，站点A请求在当前选项卡上运行脚本。由于当前选项卡显示的是站点A，扩展运行该脚本。然而，站点A可以导航到站点B，并且脚本在站点B中执行。

更糟糕的是，扩展API没有提供直接的方法（如isTrusted）来验证发送者，并且存在若干实现错误，我们将在第8节进一步讨论。

```jsx
jsx复制代码
// 易受攻击的扩展后台页面
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
	// 错误地验证URL
	if (sender.url.startsWith("https://admin.com") && message == "getCredentials")
		sendResponse(credentials);
});

// 攻击者RW在https://admin.com.attacker.com
chrome.runtime.sendMessage("getCredentials")

```

例如，回想之前的密码管理器扩展示例。请求凭据列表的扩展消息应仅来自在管理页面上运行的内容脚本。然而，如果扩展页面未检查（或错误地检查）发送者，则无法控制管理页面的攻击者也可以请求凭据（如图2中的1所示）。列表1显示了易受攻击的模式和POC漏洞。后台页面仅验证URL前缀，因此攻击者RW可以注册https://admin.com.attacker.com并发送请求凭据的消息。

## 3.2 扩展存储中的非敏感数据

扩展存储用于存储扩展的持久数据，扩展页面和内容脚本均可访问这些数据。从安全角度来看，注入内容脚本的渲染器进程应能够访问扩展存储。因此，一旦渲染器进程被攻破，攻击者RW可以读取和修改扩展存储，并且只有对网站安全的数据应存储在扩展存储中。

**安全要求2**：扩展不应在扩展存储中存储安全关键、隐私敏感或跨站点数据。

我们发现许多情况下，扩展存储上的安全要求未得到遵守。完整的扩展列表见表1。我们怀疑这是因为扩展开发人员认为扩展存储只能被他们编写的扩展页面和内容脚本访问。因此，扩展开发人员认为攻击者无法访问扩展存储，因此存储敏感数据。

```jsx
jsx复制代码
// 易受攻击的扩展后台页面
// 将凭据存储在扩展存储中
chrome.storage.set("credentials", credentials);

// 攻击者RW在任何页面上
chrome.storage.get("credentials")
```

列表2：易受攻击的模式和POC漏洞。

例如，回想之前的密码管理器扩展示例。凭据存储在扩展存储中，允许攻击者非法访问凭据（如图2中的2所示）。列表2显示了易受攻击的模式和POC漏洞。后台页面将凭据存储在扩展存储中，因此攻击者RW可以在任何页面上检索它们。

## 3.3 内容脚本中的非敏感数据

内容脚本在渲染器进程中运行，因为它直接与DOM交互。换句话说，内容脚本在渲染器进程的地址空间中，攻击者R和攻击者RW可以读取它。这尤其令人担忧，因为攻击者R不依赖于浏览器中的漏洞，难以缓解。

此外，Chrome和Firefox尝试通过仅将高粒度计时器的可用性限制为跨源隔离页面来缓解计时侧信道攻击。然而，跨源隔离不影响内容脚本注入，因此网页可以使用高粒度计时器对内容脚本进行攻击。

因此，扩展不应在内容脚本中存储任何敏感数据。

**安全要求3**：扩展不应在内容脚本中加载安全关键或隐私敏感数据。

```jsx
jsx复制代码
// 易受攻击的扩展后台页面
// 将敏感数据发送到内容脚本
chrome.tabs.sendMessage(tabId, sensitiveData);

// 消息在渲染器进程的消息队列中排队，
// 因此攻击者R可以读取消息
readMemory();
```

列表3：易受攻击的模式和POC漏洞。

然而，我们发现有几个扩展未遵循这一安全要求（见表1），原因与上述情况类似——即，扩展开发人员未考虑攻击者R和攻击者RW的威胁模型。换句话说，扩展开发人员认为放置在内容脚本中的数据只能由内容脚本本身访问。列表3显示了易受攻击的模式和POC漏洞。后台页面将敏感数据发送到内容脚本，攻击者R可以读取该数据。

# 4 通过扩展实现的权限提升攻击

鉴于扩展程序的安全要求，我们分析了现实世界中的扩展程序是否满足这些要求。不幸的是，我们发现许多扩展程序未能满足这些要求，导致权限提升攻击。

基于我们的分析，我们设计了三种新的权限提升攻击，允许绕过同源策略 (SOP) 并在其他站点上执行脚本，即通用跨站脚本 (UXSS)。通过UXSS，攻击者可以绕过SOP，窃取数据（例如读取受害者的电子邮件），并代表受害者执行操作（例如进行银行转账）。在下面，我们将描述这三种攻击，即执行特权浏览器API (§4.1)、写入敏感扩展数据 (§4.2) 和读取敏感扩展数据 (§4.3)，其整体攻击流程如图3所示。

方法论。我们修改了ExtensionCrawler以收集截至2022年4月9日的Chrome Web Store和Firefox Add-ons中的扩展。我们排除了2020年被废弃的Chrome应用和没有JavaScript组件的主题。我们还排除了无法下载或未列出的扩展（即不出现在搜索结果中的扩展）。由于Safari不允许抓取和下载扩展，我们无法收集Safari的扩展。

然后，我们选择了每个浏览器中用户最多的前20个扩展。我们还选择了与Chrome、Opera、Brave和Whale捆绑的扩展。Firefox和Safari没有捆绑扩展。易受攻击的扩展列表在表中列出，完整的分析扩展列表在表中。

我们安装了每个扩展，并检查了交换的消息和存储的数据。我们开发了一个DevTools扩展来拦截扩展消息并浏览扩展存储。然后，我们手动检查了扩展的源代码，重点关注扩展消息的处理方式和存储数据的使用方式。

## 4.1 执行特权浏览器API

由于浏览器API可以访问其他站点的数据或修改浏览器行为，调用浏览器API的扩展消息应进行身份验证（§3.1中描述的安全要求1）。然而，我们发现许多扩展未能满足此要求，即它们要么不进行身份验证，要么错误地进行身份验证。具体来说，我们发现23个扩展（包括15个组件扩展）允许攻击者不受限制地访问特权浏览器API。

案例研究：Honey。Honey扩展允许不受限制地访问executeScript API，从而允许在打开的标签页中执行任意JavaScript，导致UXSS。它还将标签事件广播给所有内容脚本，将其他标签信息留在内容脚本内存中。

案例研究：Tampermonkey。该扩展允许调用浏览器API，例如fetch、tabs和cookies API，从而允许绕过SOP并读取跨站数据。

案例研究：ClassLink OneClick Extension。tabs和executeScript API使用标签ID来指定标签。标签ID对每个标签是唯一的，而不是对每个站点，即使标签导航到另一个站点，ID也不会改变。通过在页面卸载时发送请求，绑定到当前标签的API调用将被发送到新站点。攻击者可以利用这一竞态，通过在卸载事件时发送请求来执行脚本，并且脚本将在新站点上执行，导致UXSS。

案例研究：Opera组件扩展。Opera将settingsPrivate API暴露给内容脚本，允许攻击者修改浏览器设置。DNS/代理设置可以被操纵以执行中间人攻击（MITM）。此外，一些设置已被用来执行UXSS或逃离沙箱。

## 4.2 写入敏感扩展数据

由于扩展页面比内容脚本具有更高的特权，影响扩展页面行为的配置不应由内容脚本修改。因此，它们不应通过来自内容脚本的扩展消息进行修改（根据安全要求1）或不应存储在扩展存储中（根据安全要求2）。

然而，我们发现许多扩展允许通过扩展消息进行修改（违反安全要求1）或在扩展存储中存储敏感配置（违反安全要求2），使攻击者可以操纵扩展行为。我们重点关注影响存储在扩展存储中的注入脚本的配置，最终导致UXSS。

案例研究：广告拦截器。广告拦截器允许用户添加自定义规则，有些规则允许注入脚本以移除动态注入的广告（在Adblock Plus和AdBlock中，只能注入预定义的脚本）。例如，过滤规则 [example.com#%#alert(document.domain)](http://example.com/#%25#alert(document.domain)) 会在 [example.com](http://example.com/) 上执行 alert(document.domain)。

在六个广告拦截器中，攻击者可以伪造请求添加自定义规则，并在网站上运行任意代码。这六个广告拦截器还将自定义规则存储在扩展存储中，攻击者可以修改这些规则。

案例研究：Tampermonkey。用户脚本管理器Tampermonkey允许用户添加一个脚本，称为用户脚本，在特定页面上运行，就像内容脚本一样。在Tampermonkey中，攻击者可以伪造请求添加用户脚本，并在网站上运行任意用户脚本。Tampermonkey还将用户脚本存储在扩展存储中，攻击者可以修改这些脚本。

此外，用户脚本可以通过内容脚本向后台页面请求来访问扩展API。攻击者可以伪造请求并调用扩展API。

案例研究：Google Translate。Google Translate扩展通过向页面注入脚本来翻译页面。用户可以从列表中选择翻译成的语言，这个配置存储在扩展存储中。由于配置只能是预定值之一，扩展会直接注入该值而不先验证它。攻击者可以将值修改为任意值，例如脚本，并在翻译的页面上执行脚本（XSS）。

## 4.3 读取敏感扩展数据

在处理安全敏感数据时，扩展程序应仔细存储并安全控制这些数据的访问。因此，为了防止渲染器攻击者访问数据，敏感数据不应通过扩展消息访问（安全要求1），也不应存储在扩展存储（安全要求2）或内容脚本内存（安全要求3）中。然而，我们发现19个扩展未能满足这些要求，使敏感数据暴露给攻击者。

案例研究：Windows Account and Office。Windows Account and Office扩展允许用户使用Windows或Azure Active Directory (AAD) 账户在Windows上登录。当用户访问登录页面时，内容脚本请求后台页面从操作系统检索令牌。通过将URL伪装为登录页面，攻击者可以窃取令牌并接管账户。

案例研究：密码管理器。密码管理器存储网站的凭据。当用户访问登录页面时，内容脚本请求扩展页面提供已保存的凭据。在LastPass和Bitwarden密码管理器中，通过将URL伪装为目标站点，攻击者可以窃取该站点的凭据。两个密码管理器还将加密密钥存储在扩展存储中，攻击者可以访问这些密钥。

我们对另外六个密码管理器进行了额外分析，发现所有密码管理器中，攻击者都可以窃取凭据。在四个密码管理器中，攻击者可以访问加密密钥。

案例研究：加密货币钱包。加密货币钱包存储用于在区块链上签署交易的私钥。当页面请求签署交易时，内容脚本将请求转发给后台页面，后台页面向用户显示确认交易的通知。如果用户确认交易，通知将发送请求以签署交易。在MetaMask中，攻击者可以伪造确认消息，签署任意交易。MetaMask还将交易队列存储在扩展存储中，攻击者可以向其中添加任意交易。

我们对另外七个加密货币钱包进行了额外分析，发现四个钱包中，攻击者可以签署任意交易。

此外，用户可以在弹出窗口中查看助记词和私钥。当用户请求查看助记词和私钥时，弹出窗口请求后台页面发送它们。在Phantom、TronLink和Kaikas中，攻击者可以伪造请求并检索助记词和/或私钥。

# 5 FISTBUMP 的设计

在有渲染器攻击者（AttackerRW 和 AttackerR）存在的情况下，当前的扩展架构要求扩展开发者遵循 §3 中提出的三个安全要求。然而，对于扩展开发者来说，正确地在扩展页面和内容脚本之间分离权限是具有挑战性的，并且这些安全要求往往会被违反，从而导致严重的权限提升攻击。

基于这些原因，我们提出了 FISTBUMP，这是一种新的扩展架构，通过强大的进程隔离来保护内容脚本免受渲染器攻击者的攻击。为此，FISTBUMP 重新设计了扩展架构，使内容脚本运行在扩展进程中，而不是渲染器进程中。结果，运行内容脚本的进程与渲染器进程隔离，利用进程作为保护域，防止攻击者获取内容脚本的功能。换句话说，攻击者不能伪造扩展消息或访问扩展存储。

因此，FISTBUMP 在设计上满足了三个安全要求，并消除了 §4 中提出的漏洞。从扩展开发者的角度来看，FISTBUMP 将满足安全要求的挑战性负担转移到了浏览器和操作系统上。

### 设计概述

FISTBUMP 的总体架构如图 4 所示。为了强制执行强大的进程隔离，FISTBUMP 将内容脚本移到扩展进程中（§5.1）。为了保持内容脚本的功能性和兼容性，FISTBUMP 引入了 DOMProxy（§5.2）。此外，为了优化 DOMProxy 的性能，FISTBUMP 进一步开发了定制的内存管理以及批处理（§5.3）。我们注意到 FISTBUMP 可以被扩展和浏览器采用，这将在 §8 中进一步讨论。

## 5.1 内容脚本的强进程隔离

设计目标 1：强烈隔离内容脚本与渲染器进程。

在 §3 中提到的权限提升攻击的根本原因是当前内容脚本和渲染器之间的隔离机制不足以阻止 AttackerRW 和 AttackerR。为此，FISTBUMP 采用了更强的隔离机制，即基于进程隔离。这样，运行内容脚本的进程应该与渲染器进程不同，从而防止渲染器访问内容脚本。

具体而言，FISTBUMP 将内容脚本移到扩展进程中，扩展页面也在该进程中运行。在扩展进程中，FISTBUMP 使用专用的工作线程运行每个内容脚本，以保留现代浏览器的执行特性。现代浏览器实现了独立的浏览器标签，因此渲染器进程及其相关扩展的执行上下文是相互独立的。内容脚本的生命周期如下：首先，当要注入内容脚本时（例如，渲染器进程加载页面时），FISTBUMP 创建一个工作线程并在扩展进程中运行内容脚本。如果页面稍后卸载，那么 FISTBUMP 相应地终止内容脚本工作线程。

内容脚本工作线程也运行在一个隔离世界中，这是一个私有的执行环境，其权限限制在与原始内容脚本相同的级别。内容安全策略（CSP）设置为防止内容脚本工作线程执行远程代码，例如，不包括在扩展中的代码。

结果，内容脚本数据被保存在渲染器进程之外，通过设计保护其免受 AttackerR 和 AttackerRW 的攻击。

此外，渲染器不再需要内容脚本的权限，例如发送扩展消息或访问扩展存储。遵循最小特权原则（PoLP），FISTBUMP 从渲染器进程中删除这些权限，因此被攻破的渲染器不再能够冒充内容脚本。

## 5.2 通过 DOM Proxy 实现透明隔离

设计目标 2：提供与向后兼容的内容脚本透明隔离。

显然，添加强大的隔离机制可能会导致软件架构的重大变化和非平凡的工程成本。例如，为了执行站点隔离（也采用了进程隔离），浏览器供应商已经投入了非平凡的工程成本【49】。为了将工程成本降到最低，FISTBUMP 旨在提供与向后兼容的透明隔离机制。更确切地说，FISTBUMP 的隔离机制不应干扰任何网页扩展的功能特性，并且应能够在不进行手动修改的情况下运行现有的浏览器扩展。

### 透明的 DOM 代理与委托

**内容脚本的主要功能是与页面的 DOM 交互。**这为 FISTBUMP 提出了一个问题，需要一种新的机制来连接内容脚本和 DOM。具体而言，当前的浏览器架构将所有这些组件（即内容脚本、DOM 和页面脚本）放在同一个渲染器进程中，内容脚本可以直接访问 DOM。然而，FISTBUMP 将内容脚本从渲染器进程中移到了扩展进程中。因此，内容脚本具有独立的虚拟地址空间，不能直接访问 DOM。

为了解决这个问题，FISTBUMP 通过代理进行 DOM 访问。FISTBUMP 没有将内容脚本注入到渲染器进程中，而是插入了一个与 DOM 交互的代理，我们称之为 DOMProxy。内容脚本工作线程和 DOMProxy 使用 IPC 进行通信。它们交换 JSON 序列化的消息，包含纯粹的 DOM 操作或事件数据。

当内容脚本在扩展进程中访问 DOM 对象时，内容脚本工作线程将操作转发给 DOMProxy。然后 DOMProxy 执行请求的操作，并返回 i) 结果值或 ii) 结果对象的引用。如果返回的是引用，内容脚本工作线程为给定的引用创建一个代理对象，并拦截代理对象上的所有操作并将其转发给 DOMProxy。

内容脚本还可以为 DOM 事件注册监听器。如果内容脚本注册了事件监听器，DOMProxy 将注册一个相应的代理事件监听器。如果事件在渲染器进程中触发，该事件将由 DOMProxy 转发给内容脚本工作线程。然后内容脚本工作线程引发代理事件（即原始事件的克隆），最终将其分派到内容脚本中的目标事件监听器。

### 示例：内容脚本执行

为了清楚展示 DOMProxy 的操作方式，我们提供一个示例，展示 DOMProxy 如何执行内容脚本代码 `alert(document.domain)`。图 5 右侧显示了抽象语法树（AST）。

首先，JavaScript 评估 `alert`，这是在查找名为 `alert` 的标识符。内容脚本工作线程拦截并转发 `GET("alert")` 请求给 DOMProxy。由于 `alert` 是一个函数，DOMProxy 创建一个引用 `REFalert` 并返回 ID（#1）给内容脚本工作线程。收到引用后，内容脚本工作线程创建一个代理函数 `DELalert`。

其次，JavaScript 评估 `document`。同样，由于 `document` 是一个对象，DOMProxy 创建一个引用 `REFdocument` 并返回 ID（#2）。内容脚本工作线程创建一个代理对象 `DELdocument`。

然后，JavaScript 评估 `DELdocument.domain`。这是一个成员表达式，检索名为 `domain` 的属性。内容脚本工作线程拦截并转发 `GET(#2, "domain")` 请求给 DOMProxy。DOMProxy 检索与 #2 对应的对象 `document`，并查找名为 `domain` 的属性，其值为 `[example.com](http://example.com)`。由于其类型是字符串原语，DOMProxy 如实发送它。

最后，JavaScript 评估 `DELalert("[example.com](http://example.com)")`，即调用 `DELalert` 并传递参数 `"[example.com](http://example.com)"`。内容脚本工作线程转发 `CALL(#1, "[example.com](http://example.com)")` 请求给 DOMProxy，DOMProxy 检索与 #1 对应的函数 `alert` 并评估 `alert("[example.com](http://example.com)")`，这相当于在内容脚本中运行 `alert(document.domain)`。

### 转发扩展 API 调用

内容脚本的另一个功能是调用扩展 API。如 §2 中所述，当前的浏览器架构通过在两个不同进程之间传递 IPC 消息来实现扩展 API 调用。然而，由于 FISTBUMP 将内容脚本和后台页面置于同一进程中，因此不再需要 IPC 消息传递。因此，FISTBUMP 实现了一个进程内扩展 API 调用机制，该机制由内容脚本工作线程转发。具体来说，所有内容脚本的扩展 API 调用首先由内容脚本工作线程拦截。然后内容脚本工作线程将调用转发给后台页面。

## 5.3 优化 DOM Proxy 的性能

设计目标 3：在合理的性能开销下提供隔离。

由于 FISTBUMP 代理了内容脚本的所有 DOM 访问，这使内容脚本的执行行为复杂化，从而在内存管理和执行速度方面对性能产生负面影响。

### 内存管理

DOMProxy 的一个问题是，即使在内容脚本工作线程中不再使用，DOMProxy 中对对象和函数的引用也会累积，从而导致内存泄漏。DOMProxy 通过在内容脚本工作线程中代理对象被垃圾收集时删除引用来解决这个问题。

### 批处理和缓存

为了减少进程间通信的数量，内容脚本维护一个没有副作用的代理操作队列，并批量发送它们。内容脚本工作线程维护一个虚拟 DOM 表示，且不依赖于文档的操作（例如，对孤立节点的操作）在内容脚本工作线程中执行。内容脚本工作线程还缓存不变的或其有效性可以轻易检查的属性。

# 7 评估

在本节中，我们评估了 FISTBUMP 的各个方面，特别关注其安全性（§7.1）、兼容性（§7.2）和性能（§7.3）。

实验设置。我们在配备 Intel i7-10700K 和 32 GB RAM 的机器上测试了我们的实现。我们基于 101.0.4951.41 标签构建了 Chromium 浏览器。为了进行比较，我们准备了两组浏览器，一组带有 FISTBUMP，另一组不带 FISTBUMP。我们使用 DOM 模糊测试工具 Domato 生成测试 HTML，并使用 Domato 提供的 html.txt 语法。

## 7.1 安全性

FISTBUMP 的首要目标是加强当前扩展架构的最小特权原则（PoLP）。因此，我们在本小节中评估 FISTBUMP 的安全性。

**安全分析。**如 §3 中所述，当前的扩展架构要求扩展开发者遵循三项安全要求。这实际上激励了 FISTBUMP 的设计，旨在满足所有这些安全要求。以下是对 FISTBUMP 如何满足每项安全要求的设计进行的描述和推理。

1. 首先，在 FISTBUMP 中，渲染器进程无法发送扩展消息，因为内容脚本已移至扩展进程。因此，消息只能来自扩展进程（对 AttackerRW 安全），因此所有发送者信息都是可信的。因此，FISTBUMP 不再要求扩展开发者承担安全要求 1，并消除了所有相应的漏洞。
2. 其次，在 FISTBUMP 中，渲染器进程无法访问扩展存储，因为扩展存储仅可从扩展进程访问。因此，保存在扩展存储中的所有数据都对 AttackerRW 是安全的，消除了所有与安全要求 2 相关的漏洞。
3. 最后，渲染器进程无法访问内容脚本的内存占用，因为在 FISTBUMP 中，内容脚本在独立的虚拟地址空间中运行。因此，AttackerR 和 AttackerRW 无法从内容脚本中获取任何数据，从而 FISTBUMP 不再要求扩展开发者承担安全要求 3，并缓解了所有相应的漏洞。

将内容脚本移至扩展进程可能会暴露额外的攻击面。AttackerRW 可以伪造来自 DOMProxy 的消息，但 DOMProxy 和内容脚本工作线程之间的消息使用现有的扩展消息实现，并且仅包含纯结构化数据。它们不交换 JavaScript 代码或指针，并且 DOMProxy 不能直接更改内容脚本工作线程的控制流。

此外，内容脚本工作线程以内容脚本权限运行，不能运行远程代码，例如攻击者提供的代码。因此，攻击者要利用扩展进程，他们需要找到：

- 内容脚本中的任意代码执行漏洞和 CSP 绕过漏洞，或
- 触发的内容脚本中的代码片段和利用内存破坏的代码片段。

我们认为这些漏洞难以发现，即使发现，也不需要扩展就可以进行更严重的攻击。2022 年没有报告 CSP 绕过漏洞，所有内存破坏漏洞都需要传递无效参数或特定用户交互【18】，这些在正常的内容脚本中极不可能发生。

**漏洞缓解。**为了检查 FISTBUMP 是否阻止了我们在 §4 中演示的具体攻击，我们尝试在运行 FISTBUMP 的 Chromium 浏览器中重现攻击。对于每个扩展，我们首先在启用了 FISTBUMP 的 Chrome 中安装它，然后基于类型混淆漏洞 CVE-2022-1134【42】启动渲染器远程代码执行（RCE）攻击。然后我们执行了 §4 中创建的特权提升攻击 PoC。结果表明，针对所有测试扩展的相同特权提升攻击不再有效，表明 FISTBUMP 的安全设计及其实现如预期有效。

## 7.2 向后兼容性

单元测试。我们运行了一个包含 75 个内容脚本 API 单元测试的 Chromium 单元测试套件【17】。我们发现所有 75 个单元测试都通过了，表明 FISTBUMP 的内容脚本实现是正确且向后兼容的。

限制。JavaScript 使用事件循环，等待并处理消息队列中的消息。每个消息是一个函数调用并运行到完成，即在处理下一个消息之前完全处理当前消息。换句话说，消息处理会阻塞运行时。然而，使用 DOMProxy，每个表达式或语句在单独的消息中进行评估。这允许其他消息（例如事件处理程序）在运行代码块时处理中途执行，导致不一致。

我们测试了所有分析过的扩展，了解此限制如何影响它们的操作。我们在启用了 FISTBUMP 的浏览器和原始浏览器上安装扩展，并在执行其功能时比较它们的行为。例如，对于密码管理器扩展，我们保存密码并检查它是否成功填充到登录表单中。

我们没有发现此限制改变扩展行为的实例。尽管如此，为确保一致性，DOMProxy 可以实现为同步，阻塞事件循环直到内容脚本工作线程运行完成。

## 7.3 性能

浏览器的运行时性能始终是关键，因为它显著影响用户体验。由于内容脚本工作线程使用相同的 JavaScript 引擎，因此运行纯 JavaScript 没有额外开销。然而，由于 FISTBUMP 在扩展架构中引入了非平凡的更改，我们测量了 FISTBUMP 中 DOM 操作和扩展 API 调用的性能开销。图 6 显示了每个操作的平均运行时间与原始浏览器的比较。

DOMProxy 和内容脚本之间的 IPC 开销在单个 DOM 操作（例如读取内容（dom.read）或设置元素的值（dom.write））中引入了大约 235 纳秒的延迟。然而，常见的 DOM 操作（例如插入元素（dom.insert））由多个无副作用的操作组成。通过批处理，这些操作可以通过单个 IPC 处理，有效地将开销减少到大约 7 纳秒（13%）。

我们在调用基本扩展 API（例如检索元数据（api.metadata））时看到了大约 28% 的性能提升，因为扩展进程可以直接处理请求。我们还观察到扩展消息传递（message.cs/ep）大约 87% 的改进，因为它在扩展进程中处理，而不是通过 IPC。然

而，存储访问（storage.get/set）有大约 9% 的开销，可能是因为内容脚本工作线程必须通过后台页面访问扩展存储。

因此，对于具有大量 DOM 或存储操作的扩展，FISTBUMP 显示出最多 13% 的运行时开销，对于消息传递繁重的扩展可能会显示性能改进。

内存。为了测量内存开销，我们使用 Chrome DevTools 拍摄了内存快照。DOMProxy 和内容脚本工作线程增加了大约 3.4 MB 的内存开销，每次创建委托对象和相应引用时增加额外的 1.2 KB。当内存压力较大时，我们观察到不再使用的委托对象引用成功地被垃圾回收。

---

# 相关知识

## SOP

### 同源策略的定义

根据同源策略，如果两个URL具有相同的协议（如HTTP或HTTPS）、相同的域名以及相同的端口号，那么它们被视为“同源”。如果任何一个组成部分不同，它们则被视为“不同源”。在同源策略的保护下，一个网站的脚本只能访问属于同一来源的资源，避免了跨站脚本（XSS）等攻击。

### 论文中的SOP相关内容

在论文中，同源策略被提到作为浏览器安全的基本原则之一。它的主要作用是防止渲染进程攻击者（如AttackerR和AttackerRW）跨站访问数据。例如，尽管内容脚本运行在非特权的渲染进程中，遵循SOP可以阻止这些脚本访问其他网站的数据，即使攻击者能读取或写入渲染进程的内存。

### 渲染进程中的威胁

渲染进程被设计为不信任的，因而被严格限制在自己的权限范围内。即便渲染进程被攻破，由于同源策略的存在，攻击者不能通过一个被攻破的渲染进程访问其他来源的数据。这确保了一个网站的漏洞不会轻易波及其他网站的数据。

### Site Isolation与SOP的结合

为了进一步增强安全性，Chrome和Firefox浏览器采用了站点隔离（Site Isolation）技术。这种技术将每个网站分配到不同的渲染进程中，即使不同来源的网站嵌套在一起（例如，example.com嵌入了example.org的内容），它们也会在不同的进程中运行。通过这种方式，即使一个渲染进程被攻破，同源策略和站点隔离技术依然可以保护其他网站的数据不被访问。

- 扩展页面 内容脚本 浏览器进程 渲染进程
